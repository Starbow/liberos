// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eros.proto

#ifndef PROTOBUF_eros_2eproto__INCLUDED
#define PROTOBUF_eros_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobufs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_eros_2eproto();
void protobuf_AssignDesc_eros_2eproto();
void protobuf_ShutdownFile_eros_2eproto();

class Handshake;
class Division;
class HandshakeResponse;
class UserRegionStats;
class UserStats;
class MapPool;
class Map;
class SimulationResult;
class MatchmakingQueue;
class MatchmakingResult;
class ChatRoomInfo;
class ChatRoomIndex;
class ChatMessage;
class ChatRoomMessage;
class ChatPrivateMessage;
class ChatRoomUser;
class ChatRoomRequest;
class MatchmakingStats;
class ServerStats;
class Character;
class MatchParticipant;
class MatchResult;
class BroadcastAlert;

enum HandshakeResponse_HandshakeStatus {
  HandshakeResponse_HandshakeStatus_FAIL = 0,
  HandshakeResponse_HandshakeStatus_SUCCESS = 1
};
bool HandshakeResponse_HandshakeStatus_IsValid(int value);
const HandshakeResponse_HandshakeStatus HandshakeResponse_HandshakeStatus_HandshakeStatus_MIN = HandshakeResponse_HandshakeStatus_FAIL;
const HandshakeResponse_HandshakeStatus HandshakeResponse_HandshakeStatus_HandshakeStatus_MAX = HandshakeResponse_HandshakeStatus_SUCCESS;
const int HandshakeResponse_HandshakeStatus_HandshakeStatus_ARRAYSIZE = HandshakeResponse_HandshakeStatus_HandshakeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* HandshakeResponse_HandshakeStatus_descriptor();
inline const ::std::string& HandshakeResponse_HandshakeStatus_Name(HandshakeResponse_HandshakeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    HandshakeResponse_HandshakeStatus_descriptor(), value);
}
inline bool HandshakeResponse_HandshakeStatus_Parse(
    const ::std::string& name, HandshakeResponse_HandshakeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandshakeResponse_HandshakeStatus>(
    HandshakeResponse_HandshakeStatus_descriptor(), name, value);
}
enum Region {
  NA = 1,
  EU = 2,
  KR = 3,
  CN = 5,
  SEA = 6
};
bool Region_IsValid(int value);
const Region Region_MIN = NA;
const Region Region_MAX = SEA;
const int Region_ARRAYSIZE = Region_MAX + 1;

const ::google::protobuf::EnumDescriptor* Region_descriptor();
inline const ::std::string& Region_Name(Region value) {
  return ::google::protobuf::internal::NameOfEnum(
    Region_descriptor(), value);
}
inline bool Region_Parse(
    const ::std::string& name, Region* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Region>(
    Region_descriptor(), name, value);
}
// ===================================================================

class Handshake : public ::google::protobuf::Message {
 public:
  Handshake();
  virtual ~Handshake();

  Handshake(const Handshake& from);

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Handshake& default_instance();

  void Swap(Handshake* other);

  // implements Message ----------------------------------------------

  Handshake* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Handshake& from);
  void MergeFrom(const Handshake& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string auth_key = 2;
  inline bool has_auth_key() const;
  inline void clear_auth_key();
  static const int kAuthKeyFieldNumber = 2;
  inline const ::std::string& auth_key() const;
  inline void set_auth_key(const ::std::string& value);
  inline void set_auth_key(const char* value);
  inline void set_auth_key(const char* value, size_t size);
  inline ::std::string* mutable_auth_key();
  inline ::std::string* release_auth_key();
  inline void set_allocated_auth_key(::std::string* auth_key);

  // @@protoc_insertion_point(class_scope:protobufs.Handshake)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_auth_key();
  inline void clear_has_auth_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* auth_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static Handshake* default_instance_;
};
// -------------------------------------------------------------------

class Division : public ::google::protobuf::Message {
 public:
  Division();
  virtual ~Division();

  Division(const Division& from);

  inline Division& operator=(const Division& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Division& default_instance();

  void Swap(Division* other);

  // implements Message ----------------------------------------------

  Division* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Division& from);
  void MergeFrom(const Division& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int64 points = 2;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline ::google::protobuf::int64 points() const;
  inline void set_points(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protobufs.Division)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_points();
  inline void clear_has_points();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int64 points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static Division* default_instance_;
};
// -------------------------------------------------------------------

class HandshakeResponse : public ::google::protobuf::Message {
 public:
  HandshakeResponse();
  virtual ~HandshakeResponse();

  HandshakeResponse(const HandshakeResponse& from);

  inline HandshakeResponse& operator=(const HandshakeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HandshakeResponse& default_instance();

  void Swap(HandshakeResponse* other);

  // implements Message ----------------------------------------------

  HandshakeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HandshakeResponse& from);
  void MergeFrom(const HandshakeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HandshakeResponse_HandshakeStatus HandshakeStatus;
  static const HandshakeStatus FAIL = HandshakeResponse_HandshakeStatus_FAIL;
  static const HandshakeStatus SUCCESS = HandshakeResponse_HandshakeStatus_SUCCESS;
  static inline bool HandshakeStatus_IsValid(int value) {
    return HandshakeResponse_HandshakeStatus_IsValid(value);
  }
  static const HandshakeStatus HandshakeStatus_MIN =
    HandshakeResponse_HandshakeStatus_HandshakeStatus_MIN;
  static const HandshakeStatus HandshakeStatus_MAX =
    HandshakeResponse_HandshakeStatus_HandshakeStatus_MAX;
  static const int HandshakeStatus_ARRAYSIZE =
    HandshakeResponse_HandshakeStatus_HandshakeStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HandshakeStatus_descriptor() {
    return HandshakeResponse_HandshakeStatus_descriptor();
  }
  static inline const ::std::string& HandshakeStatus_Name(HandshakeStatus value) {
    return HandshakeResponse_HandshakeStatus_Name(value);
  }
  static inline bool HandshakeStatus_Parse(const ::std::string& name,
      HandshakeStatus* value) {
    return HandshakeResponse_HandshakeStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protobufs.HandshakeResponse.HandshakeStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::protobufs::HandshakeResponse_HandshakeStatus status() const;
  inline void set_status(::protobufs::HandshakeResponse_HandshakeStatus value);

  // optional .protobufs.UserStats user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::protobufs::UserStats& user() const;
  inline ::protobufs::UserStats* mutable_user();
  inline ::protobufs::UserStats* release_user();
  inline void set_allocated_user(::protobufs::UserStats* user);

  // optional int64 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // repeated .protobufs.Character character = 4;
  inline int character_size() const;
  inline void clear_character();
  static const int kCharacterFieldNumber = 4;
  inline const ::protobufs::Character& character(int index) const;
  inline ::protobufs::Character* mutable_character(int index);
  inline ::protobufs::Character* add_character();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::Character >&
      character() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::Character >*
      mutable_character();

  // repeated .protobufs.Division division = 5;
  inline int division_size() const;
  inline void clear_division();
  static const int kDivisionFieldNumber = 5;
  inline const ::protobufs::Division& division(int index) const;
  inline ::protobufs::Division* mutable_division(int index);
  inline ::protobufs::Division* add_division();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::Division >&
      division() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::Division >*
      mutable_division();

  // repeated .protobufs.Region active_region = 6;
  inline int active_region_size() const;
  inline void clear_active_region();
  static const int kActiveRegionFieldNumber = 6;
  inline ::protobufs::Region active_region(int index) const;
  inline void set_active_region(int index, ::protobufs::Region value);
  inline void add_active_region(::protobufs::Region value);
  inline const ::google::protobuf::RepeatedField<int>& active_region() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_active_region();

  // @@protoc_insertion_point(class_scope:protobufs.HandshakeResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::UserStats* user_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::RepeatedPtrField< ::protobufs::Character > character_;
  ::google::protobuf::RepeatedPtrField< ::protobufs::Division > division_;
  ::google::protobuf::RepeatedField<int> active_region_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static HandshakeResponse* default_instance_;
};
// -------------------------------------------------------------------

class UserRegionStats : public ::google::protobuf::Message {
 public:
  UserRegionStats();
  virtual ~UserRegionStats();

  UserRegionStats(const UserRegionStats& from);

  inline UserRegionStats& operator=(const UserRegionStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRegionStats& default_instance();

  void Swap(UserRegionStats* other);

  // implements Message ----------------------------------------------

  UserRegionStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserRegionStats& from);
  void MergeFrom(const UserRegionStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.Region region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::protobufs::Region region() const;
  inline void set_region(::protobufs::Region value);

  // required int64 points = 2;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 2;
  inline ::google::protobuf::int64 points() const;
  inline void set_points(::google::protobuf::int64 value);

  // required int64 wins = 3;
  inline bool has_wins() const;
  inline void clear_wins();
  static const int kWinsFieldNumber = 3;
  inline ::google::protobuf::int64 wins() const;
  inline void set_wins(::google::protobuf::int64 value);

  // required int64 losses = 4;
  inline bool has_losses() const;
  inline void clear_losses();
  static const int kLossesFieldNumber = 4;
  inline ::google::protobuf::int64 losses() const;
  inline void set_losses(::google::protobuf::int64 value);

  // required int64 forfeits = 5;
  inline bool has_forfeits() const;
  inline void clear_forfeits();
  static const int kForfeitsFieldNumber = 5;
  inline ::google::protobuf::int64 forfeits() const;
  inline void set_forfeits(::google::protobuf::int64 value);

  // required int64 walkovers = 6;
  inline bool has_walkovers() const;
  inline void clear_walkovers();
  static const int kWalkoversFieldNumber = 6;
  inline ::google::protobuf::int64 walkovers() const;
  inline void set_walkovers(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protobufs.UserRegionStats)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_wins();
  inline void clear_has_wins();
  inline void set_has_losses();
  inline void clear_has_losses();
  inline void set_has_forfeits();
  inline void clear_has_forfeits();
  inline void set_has_walkovers();
  inline void clear_has_walkovers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 points_;
  ::google::protobuf::int64 wins_;
  ::google::protobuf::int64 losses_;
  ::google::protobuf::int64 forfeits_;
  ::google::protobuf::int64 walkovers_;
  int region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static UserRegionStats* default_instance_;
};
// -------------------------------------------------------------------

class UserStats : public ::google::protobuf::Message {
 public:
  UserStats();
  virtual ~UserStats();

  UserStats(const UserStats& from);

  inline UserStats& operator=(const UserStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStats& default_instance();

  void Swap(UserStats* other);

  // implements Message ----------------------------------------------

  UserStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserStats& from);
  void MergeFrom(const UserStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required int64 search_radius = 2;
  inline bool has_search_radius() const;
  inline void clear_search_radius();
  static const int kSearchRadiusFieldNumber = 2;
  inline ::google::protobuf::int64 search_radius() const;
  inline void set_search_radius(::google::protobuf::int64 value);

  // required int64 points = 3;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 3;
  inline ::google::protobuf::int64 points() const;
  inline void set_points(::google::protobuf::int64 value);

  // required int64 wins = 4;
  inline bool has_wins() const;
  inline void clear_wins();
  static const int kWinsFieldNumber = 4;
  inline ::google::protobuf::int64 wins() const;
  inline void set_wins(::google::protobuf::int64 value);

  // required int64 losses = 5;
  inline bool has_losses() const;
  inline void clear_losses();
  static const int kLossesFieldNumber = 5;
  inline ::google::protobuf::int64 losses() const;
  inline void set_losses(::google::protobuf::int64 value);

  // required int64 forfeits = 6;
  inline bool has_forfeits() const;
  inline void clear_forfeits();
  static const int kForfeitsFieldNumber = 6;
  inline ::google::protobuf::int64 forfeits() const;
  inline void set_forfeits(::google::protobuf::int64 value);

  // required int64 walkovers = 7;
  inline bool has_walkovers() const;
  inline void clear_walkovers();
  static const int kWalkoversFieldNumber = 7;
  inline ::google::protobuf::int64 walkovers() const;
  inline void set_walkovers(::google::protobuf::int64 value);

  // repeated .protobufs.UserRegionStats region = 8;
  inline int region_size() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 8;
  inline const ::protobufs::UserRegionStats& region(int index) const;
  inline ::protobufs::UserRegionStats* mutable_region(int index);
  inline ::protobufs::UserRegionStats* add_region();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::UserRegionStats >&
      region() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::UserRegionStats >*
      mutable_region();

  // @@protoc_insertion_point(class_scope:protobufs.UserStats)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_search_radius();
  inline void clear_has_search_radius();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_wins();
  inline void clear_has_wins();
  inline void set_has_losses();
  inline void clear_has_losses();
  inline void set_has_forfeits();
  inline void clear_has_forfeits();
  inline void set_has_walkovers();
  inline void clear_has_walkovers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int64 search_radius_;
  ::google::protobuf::int64 points_;
  ::google::protobuf::int64 wins_;
  ::google::protobuf::int64 losses_;
  ::google::protobuf::int64 forfeits_;
  ::google::protobuf::int64 walkovers_;
  ::google::protobuf::RepeatedPtrField< ::protobufs::UserRegionStats > region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static UserStats* default_instance_;
};
// -------------------------------------------------------------------

class MapPool : public ::google::protobuf::Message {
 public:
  MapPool();
  virtual ~MapPool();

  MapPool(const MapPool& from);

  inline MapPool& operator=(const MapPool& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPool& default_instance();

  void Swap(MapPool* other);

  // implements Message ----------------------------------------------

  MapPool* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPool& from);
  void MergeFrom(const MapPool& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobufs.Map map = 1;
  inline int map_size() const;
  inline void clear_map();
  static const int kMapFieldNumber = 1;
  inline const ::protobufs::Map& map(int index) const;
  inline ::protobufs::Map* mutable_map(int index);
  inline ::protobufs::Map* add_map();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::Map >&
      map() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::Map >*
      mutable_map();

  // @@protoc_insertion_point(class_scope:protobufs.MapPool)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobufs::Map > map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static MapPool* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.Region region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::protobufs::Region region() const;
  inline void set_region(::protobufs::Region value);

  // required string battle_net_name = 2;
  inline bool has_battle_net_name() const;
  inline void clear_battle_net_name();
  static const int kBattleNetNameFieldNumber = 2;
  inline const ::std::string& battle_net_name() const;
  inline void set_battle_net_name(const ::std::string& value);
  inline void set_battle_net_name(const char* value);
  inline void set_battle_net_name(const char* value, size_t size);
  inline ::std::string* mutable_battle_net_name();
  inline ::std::string* release_battle_net_name();
  inline void set_allocated_battle_net_name(::std::string* battle_net_name);

  // required int32 battle_net_id = 3;
  inline bool has_battle_net_id() const;
  inline void clear_battle_net_id();
  static const int kBattleNetIdFieldNumber = 3;
  inline ::google::protobuf::int32 battle_net_id() const;
  inline void set_battle_net_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protobufs.Map)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_battle_net_name();
  inline void clear_has_battle_net_name();
  inline void set_has_battle_net_id();
  inline void clear_has_battle_net_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* battle_net_name_;
  int region_;
  ::google::protobuf::int32 battle_net_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// -------------------------------------------------------------------

class SimulationResult : public ::google::protobuf::Message {
 public:
  SimulationResult();
  virtual ~SimulationResult();

  SimulationResult(const SimulationResult& from);

  inline SimulationResult& operator=(const SimulationResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulationResult& default_instance();

  void Swap(SimulationResult* other);

  // implements Message ----------------------------------------------

  SimulationResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimulationResult& from);
  void MergeFrom(const SimulationResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.UserStats opponent = 1;
  inline bool has_opponent() const;
  inline void clear_opponent();
  static const int kOpponentFieldNumber = 1;
  inline const ::protobufs::UserStats& opponent() const;
  inline ::protobufs::UserStats* mutable_opponent();
  inline ::protobufs::UserStats* release_opponent();
  inline void set_allocated_opponent(::protobufs::UserStats* opponent);

  // required bool victory = 2;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 2;
  inline bool victory() const;
  inline void set_victory(bool value);

  // required double match_quality = 3;
  inline bool has_match_quality() const;
  inline void clear_match_quality();
  static const int kMatchQualityFieldNumber = 3;
  inline double match_quality() const;
  inline void set_match_quality(double value);

  // @@protoc_insertion_point(class_scope:protobufs.SimulationResult)
 private:
  inline void set_has_opponent();
  inline void clear_has_opponent();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_match_quality();
  inline void clear_has_match_quality();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::UserStats* opponent_;
  double match_quality_;
  bool victory_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static SimulationResult* default_instance_;
};
// -------------------------------------------------------------------

class MatchmakingQueue : public ::google::protobuf::Message {
 public:
  MatchmakingQueue();
  virtual ~MatchmakingQueue();

  MatchmakingQueue(const MatchmakingQueue& from);

  inline MatchmakingQueue& operator=(const MatchmakingQueue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakingQueue& default_instance();

  void Swap(MatchmakingQueue* other);

  // implements Message ----------------------------------------------

  MatchmakingQueue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchmakingQueue& from);
  void MergeFrom(const MatchmakingQueue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.Region region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::protobufs::Region region() const;
  inline void set_region(::protobufs::Region value);

  // required int64 radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline ::google::protobuf::int64 radius() const;
  inline void set_radius(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protobufs.MatchmakingQueue)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 radius_;
  int region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static MatchmakingQueue* default_instance_;
};
// -------------------------------------------------------------------

class MatchmakingResult : public ::google::protobuf::Message {
 public:
  MatchmakingResult();
  virtual ~MatchmakingResult();

  MatchmakingResult(const MatchmakingResult& from);

  inline MatchmakingResult& operator=(const MatchmakingResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakingResult& default_instance();

  void Swap(MatchmakingResult* other);

  // implements Message ----------------------------------------------

  MatchmakingResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchmakingResult& from);
  void MergeFrom(const MatchmakingResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timespan = 1;
  inline bool has_timespan() const;
  inline void clear_timespan();
  static const int kTimespanFieldNumber = 1;
  inline ::google::protobuf::int64 timespan() const;
  inline void set_timespan(::google::protobuf::int64 value);

  // required double quality = 2;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline double quality() const;
  inline void set_quality(double value);

  // required .protobufs.UserStats opponent = 3;
  inline bool has_opponent() const;
  inline void clear_opponent();
  static const int kOpponentFieldNumber = 3;
  inline const ::protobufs::UserStats& opponent() const;
  inline ::protobufs::UserStats* mutable_opponent();
  inline ::protobufs::UserStats* release_opponent();
  inline void set_allocated_opponent(::protobufs::UserStats* opponent);

  // required int64 opponent_latency = 4;
  inline bool has_opponent_latency() const;
  inline void clear_opponent_latency();
  static const int kOpponentLatencyFieldNumber = 4;
  inline ::google::protobuf::int64 opponent_latency() const;
  inline void set_opponent_latency(::google::protobuf::int64 value);

  // required string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // required string chat_room = 6;
  inline bool has_chat_room() const;
  inline void clear_chat_room();
  static const int kChatRoomFieldNumber = 6;
  inline const ::std::string& chat_room() const;
  inline void set_chat_room(const ::std::string& value);
  inline void set_chat_room(const char* value);
  inline void set_chat_room(const char* value, size_t size);
  inline ::std::string* mutable_chat_room();
  inline ::std::string* release_chat_room();
  inline void set_allocated_chat_room(::std::string* chat_room);

  // required .protobufs.Map map = 7;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 7;
  inline const ::protobufs::Map& map() const;
  inline ::protobufs::Map* mutable_map();
  inline ::protobufs::Map* release_map();
  inline void set_allocated_map(::protobufs::Map* map);

  // required int64 long_unlock_time = 8;
  inline bool has_long_unlock_time() const;
  inline void clear_long_unlock_time();
  static const int kLongUnlockTimeFieldNumber = 8;
  inline ::google::protobuf::int64 long_unlock_time() const;
  inline void set_long_unlock_time(::google::protobuf::int64 value);

  // required int64 long_response_time = 9;
  inline bool has_long_response_time() const;
  inline void clear_long_response_time();
  static const int kLongResponseTimeFieldNumber = 9;
  inline ::google::protobuf::int64 long_response_time() const;
  inline void set_long_response_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protobufs.MatchmakingResult)
 private:
  inline void set_has_timespan();
  inline void clear_has_timespan();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_opponent();
  inline void clear_has_opponent();
  inline void set_has_opponent_latency();
  inline void clear_has_opponent_latency();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_chat_room();
  inline void clear_has_chat_room();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_long_unlock_time();
  inline void clear_has_long_unlock_time();
  inline void set_has_long_response_time();
  inline void clear_has_long_response_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 timespan_;
  double quality_;
  ::protobufs::UserStats* opponent_;
  ::google::protobuf::int64 opponent_latency_;
  ::std::string* channel_;
  ::std::string* chat_room_;
  ::protobufs::Map* map_;
  ::google::protobuf::int64 long_unlock_time_;
  ::google::protobuf::int64 long_response_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static MatchmakingResult* default_instance_;
};
// -------------------------------------------------------------------

class ChatRoomInfo : public ::google::protobuf::Message {
 public:
  ChatRoomInfo();
  virtual ~ChatRoomInfo();

  ChatRoomInfo(const ChatRoomInfo& from);

  inline ChatRoomInfo& operator=(const ChatRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRoomInfo& default_instance();

  void Swap(ChatRoomInfo* other);

  // implements Message ----------------------------------------------

  ChatRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRoomInfo& from);
  void MergeFrom(const ChatRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bool passworded = 3;
  inline bool has_passworded() const;
  inline void clear_passworded();
  static const int kPasswordedFieldNumber = 3;
  inline bool passworded() const;
  inline void set_passworded(bool value);

  // required bool joinable = 4;
  inline bool has_joinable() const;
  inline void clear_joinable();
  static const int kJoinableFieldNumber = 4;
  inline bool joinable() const;
  inline void set_joinable(bool value);

  // required bool fixed = 5;
  inline bool has_fixed() const;
  inline void clear_fixed();
  static const int kFixedFieldNumber = 5;
  inline bool fixed() const;
  inline void set_fixed(bool value);

  // required int64 users = 6;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 6;
  inline ::google::protobuf::int64 users() const;
  inline void set_users(::google::protobuf::int64 value);

  // repeated .protobufs.UserStats participant = 7;
  inline int participant_size() const;
  inline void clear_participant();
  static const int kParticipantFieldNumber = 7;
  inline const ::protobufs::UserStats& participant(int index) const;
  inline ::protobufs::UserStats* mutable_participant(int index);
  inline ::protobufs::UserStats* add_participant();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::UserStats >&
      participant() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::UserStats >*
      mutable_participant();

  // @@protoc_insertion_point(class_scope:protobufs.ChatRoomInfo)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_passworded();
  inline void clear_has_passworded();
  inline void set_has_joinable();
  inline void clear_has_joinable();
  inline void set_has_fixed();
  inline void clear_has_fixed();
  inline void set_has_users();
  inline void clear_has_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* name_;
  ::google::protobuf::int64 users_;
  ::google::protobuf::RepeatedPtrField< ::protobufs::UserStats > participant_;
  bool passworded_;
  bool joinable_;
  bool fixed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChatRoomIndex : public ::google::protobuf::Message {
 public:
  ChatRoomIndex();
  virtual ~ChatRoomIndex();

  ChatRoomIndex(const ChatRoomIndex& from);

  inline ChatRoomIndex& operator=(const ChatRoomIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRoomIndex& default_instance();

  void Swap(ChatRoomIndex* other);

  // implements Message ----------------------------------------------

  ChatRoomIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRoomIndex& from);
  void MergeFrom(const ChatRoomIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protobufs.ChatRoomInfo room = 1;
  inline int room_size() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 1;
  inline const ::protobufs::ChatRoomInfo& room(int index) const;
  inline ::protobufs::ChatRoomInfo* mutable_room(int index);
  inline ::protobufs::ChatRoomInfo* add_room();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::ChatRoomInfo >&
      room() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::ChatRoomInfo >*
      mutable_room();

  // @@protoc_insertion_point(class_scope:protobufs.ChatRoomIndex)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::protobufs::ChatRoomInfo > room_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatRoomIndex* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::Message {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessage& default_instance();

  void Swap(ChatMessage* other);

  // implements Message ----------------------------------------------

  ChatMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // required string target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // required string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:protobufs.ChatMessage)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* target_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatRoomMessage : public ::google::protobuf::Message {
 public:
  ChatRoomMessage();
  virtual ~ChatRoomMessage();

  ChatRoomMessage(const ChatRoomMessage& from);

  inline ChatRoomMessage& operator=(const ChatRoomMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRoomMessage& default_instance();

  void Swap(ChatRoomMessage* other);

  // implements Message ----------------------------------------------

  ChatRoomMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRoomMessage& from);
  void MergeFrom(const ChatRoomMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.ChatRoomInfo room = 1;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 1;
  inline const ::protobufs::ChatRoomInfo& room() const;
  inline ::protobufs::ChatRoomInfo* mutable_room();
  inline ::protobufs::ChatRoomInfo* release_room();
  inline void set_allocated_room(::protobufs::ChatRoomInfo* room);

  // required .protobufs.UserStats sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline const ::protobufs::UserStats& sender() const;
  inline ::protobufs::UserStats* mutable_sender();
  inline ::protobufs::UserStats* release_sender();
  inline void set_allocated_sender(::protobufs::UserStats* sender);

  // required string message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:protobufs.ChatRoomMessage)
 private:
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::ChatRoomInfo* room_;
  ::protobufs::UserStats* sender_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatRoomMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatPrivateMessage : public ::google::protobuf::Message {
 public:
  ChatPrivateMessage();
  virtual ~ChatPrivateMessage();

  ChatPrivateMessage(const ChatPrivateMessage& from);

  inline ChatPrivateMessage& operator=(const ChatPrivateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatPrivateMessage& default_instance();

  void Swap(ChatPrivateMessage* other);

  // implements Message ----------------------------------------------

  ChatPrivateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatPrivateMessage& from);
  void MergeFrom(const ChatPrivateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.UserStats sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::protobufs::UserStats& sender() const;
  inline ::protobufs::UserStats* mutable_sender();
  inline ::protobufs::UserStats* release_sender();
  inline void set_allocated_sender(::protobufs::UserStats* sender);

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:protobufs.ChatPrivateMessage)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::UserStats* sender_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatPrivateMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChatRoomUser : public ::google::protobuf::Message {
 public:
  ChatRoomUser();
  virtual ~ChatRoomUser();

  ChatRoomUser(const ChatRoomUser& from);

  inline ChatRoomUser& operator=(const ChatRoomUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRoomUser& default_instance();

  void Swap(ChatRoomUser* other);

  // implements Message ----------------------------------------------

  ChatRoomUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRoomUser& from);
  void MergeFrom(const ChatRoomUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.ChatRoomInfo room = 1;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 1;
  inline const ::protobufs::ChatRoomInfo& room() const;
  inline ::protobufs::ChatRoomInfo* mutable_room();
  inline ::protobufs::ChatRoomInfo* release_room();
  inline void set_allocated_room(::protobufs::ChatRoomInfo* room);

  // required .protobufs.UserStats user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::protobufs::UserStats& user() const;
  inline ::protobufs::UserStats* mutable_user();
  inline ::protobufs::UserStats* release_user();
  inline void set_allocated_user(::protobufs::UserStats* user);

  // @@protoc_insertion_point(class_scope:protobufs.ChatRoomUser)
 private:
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::ChatRoomInfo* room_;
  ::protobufs::UserStats* user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatRoomUser* default_instance_;
};
// -------------------------------------------------------------------

class ChatRoomRequest : public ::google::protobuf::Message {
 public:
  ChatRoomRequest();
  virtual ~ChatRoomRequest();

  ChatRoomRequest(const ChatRoomRequest& from);

  inline ChatRoomRequest& operator=(const ChatRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRoomRequest& default_instance();

  void Swap(ChatRoomRequest* other);

  // implements Message ----------------------------------------------

  ChatRoomRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRoomRequest& from);
  void MergeFrom(const ChatRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string room = 1;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 1;
  inline const ::std::string& room() const;
  inline void set_room(const ::std::string& value);
  inline void set_room(const char* value);
  inline void set_room(const char* value, size_t size);
  inline ::std::string* mutable_room();
  inline ::std::string* release_room();
  inline void set_allocated_room(::std::string* room);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:protobufs.ChatRoomRequest)
 private:
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* room_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ChatRoomRequest* default_instance_;
};
// -------------------------------------------------------------------

class MatchmakingStats : public ::google::protobuf::Message {
 public:
  MatchmakingStats();
  virtual ~MatchmakingStats();

  MatchmakingStats(const MatchmakingStats& from);

  inline MatchmakingStats& operator=(const MatchmakingStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakingStats& default_instance();

  void Swap(MatchmakingStats* other);

  // implements Message ----------------------------------------------

  MatchmakingStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchmakingStats& from);
  void MergeFrom(const MatchmakingStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.Region region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::protobufs::Region region() const;
  inline void set_region(::protobufs::Region value);

  // required int64 searching_users = 2;
  inline bool has_searching_users() const;
  inline void clear_searching_users();
  static const int kSearchingUsersFieldNumber = 2;
  inline ::google::protobuf::int64 searching_users() const;
  inline void set_searching_users(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protobufs.MatchmakingStats)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_searching_users();
  inline void clear_has_searching_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 searching_users_;
  int region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static MatchmakingStats* default_instance_;
};
// -------------------------------------------------------------------

class ServerStats : public ::google::protobuf::Message {
 public:
  ServerStats();
  virtual ~ServerStats();

  ServerStats(const ServerStats& from);

  inline ServerStats& operator=(const ServerStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerStats& default_instance();

  void Swap(ServerStats* other);

  // implements Message ----------------------------------------------

  ServerStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerStats& from);
  void MergeFrom(const ServerStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 active_users = 1;
  inline bool has_active_users() const;
  inline void clear_active_users();
  static const int kActiveUsersFieldNumber = 1;
  inline ::google::protobuf::int64 active_users() const;
  inline void set_active_users(::google::protobuf::int64 value);

  // required int64 searching_users = 2;
  inline bool has_searching_users() const;
  inline void clear_searching_users();
  static const int kSearchingUsersFieldNumber = 2;
  inline ::google::protobuf::int64 searching_users() const;
  inline void set_searching_users(::google::protobuf::int64 value);

  // repeated .protobufs.MatchmakingStats region = 3;
  inline int region_size() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 3;
  inline const ::protobufs::MatchmakingStats& region(int index) const;
  inline ::protobufs::MatchmakingStats* mutable_region(int index);
  inline ::protobufs::MatchmakingStats* add_region();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::MatchmakingStats >&
      region() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::MatchmakingStats >*
      mutable_region();

  // @@protoc_insertion_point(class_scope:protobufs.ServerStats)
 private:
  inline void set_has_active_users();
  inline void clear_has_active_users();
  inline void set_has_searching_users();
  inline void clear_has_searching_users();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 active_users_;
  ::google::protobuf::int64 searching_users_;
  ::google::protobuf::RepeatedPtrField< ::protobufs::MatchmakingStats > region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static ServerStats* default_instance_;
};
// -------------------------------------------------------------------

class Character : public ::google::protobuf::Message {
 public:
  Character();
  virtual ~Character();

  Character(const Character& from);

  inline Character& operator=(const Character& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Character& default_instance();

  void Swap(Character* other);

  // implements Message ----------------------------------------------

  Character* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Character& from);
  void MergeFrom(const Character& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.Region region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::protobufs::Region region() const;
  inline void set_region(::protobufs::Region value);

  // required int32 subregion = 2;
  inline bool has_subregion() const;
  inline void clear_subregion();
  static const int kSubregionFieldNumber = 2;
  inline ::google::protobuf::int32 subregion() const;
  inline void set_subregion(::google::protobuf::int32 value);

  // required int32 profile_id = 3;
  inline bool has_profile_id() const;
  inline void clear_profile_id();
  static const int kProfileIdFieldNumber = 3;
  inline ::google::protobuf::int32 profile_id() const;
  inline void set_profile_id(::google::protobuf::int32 value);

  // required string character_name = 4;
  inline bool has_character_name() const;
  inline void clear_character_name();
  static const int kCharacterNameFieldNumber = 4;
  inline const ::std::string& character_name() const;
  inline void set_character_name(const ::std::string& value);
  inline void set_character_name(const char* value);
  inline void set_character_name(const char* value, size_t size);
  inline ::std::string* mutable_character_name();
  inline ::std::string* release_character_name();
  inline void set_allocated_character_name(::std::string* character_name);

  // optional int32 character_code = 5;
  inline bool has_character_code() const;
  inline void clear_character_code();
  static const int kCharacterCodeFieldNumber = 5;
  inline ::google::protobuf::int32 character_code() const;
  inline void set_character_code(::google::protobuf::int32 value);

  // optional string profile_link = 6;
  inline bool has_profile_link() const;
  inline void clear_profile_link();
  static const int kProfileLinkFieldNumber = 6;
  inline const ::std::string& profile_link() const;
  inline void set_profile_link(const ::std::string& value);
  inline void set_profile_link(const char* value);
  inline void set_profile_link(const char* value, size_t size);
  inline ::std::string* mutable_profile_link();
  inline ::std::string* release_profile_link();
  inline void set_allocated_profile_link(::std::string* profile_link);

  // optional string ingame_profile_link = 7;
  inline bool has_ingame_profile_link() const;
  inline void clear_ingame_profile_link();
  static const int kIngameProfileLinkFieldNumber = 7;
  inline const ::std::string& ingame_profile_link() const;
  inline void set_ingame_profile_link(const ::std::string& value);
  inline void set_ingame_profile_link(const char* value);
  inline void set_ingame_profile_link(const char* value, size_t size);
  inline ::std::string* mutable_ingame_profile_link();
  inline ::std::string* release_ingame_profile_link();
  inline void set_allocated_ingame_profile_link(::std::string* ingame_profile_link);

  // optional bool verified = 8;
  inline bool has_verified() const;
  inline void clear_verified();
  static const int kVerifiedFieldNumber = 8;
  inline bool verified() const;
  inline void set_verified(bool value);

  // optional int32 verification_portrait = 9;
  inline bool has_verification_portrait() const;
  inline void clear_verification_portrait();
  static const int kVerificationPortraitFieldNumber = 9;
  inline ::google::protobuf::int32 verification_portrait() const;
  inline void set_verification_portrait(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protobufs.Character)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_subregion();
  inline void clear_has_subregion();
  inline void set_has_profile_id();
  inline void clear_has_profile_id();
  inline void set_has_character_name();
  inline void clear_has_character_name();
  inline void set_has_character_code();
  inline void clear_has_character_code();
  inline void set_has_profile_link();
  inline void clear_has_profile_link();
  inline void set_has_ingame_profile_link();
  inline void clear_has_ingame_profile_link();
  inline void set_has_verified();
  inline void clear_has_verified();
  inline void set_has_verification_portrait();
  inline void clear_has_verification_portrait();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int region_;
  ::google::protobuf::int32 subregion_;
  ::std::string* character_name_;
  ::google::protobuf::int32 profile_id_;
  ::google::protobuf::int32 character_code_;
  ::std::string* profile_link_;
  ::std::string* ingame_profile_link_;
  bool verified_;
  ::google::protobuf::int32 verification_portrait_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static Character* default_instance_;
};
// -------------------------------------------------------------------

class MatchParticipant : public ::google::protobuf::Message {
 public:
  MatchParticipant();
  virtual ~MatchParticipant();

  MatchParticipant(const MatchParticipant& from);

  inline MatchParticipant& operator=(const MatchParticipant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchParticipant& default_instance();

  void Swap(MatchParticipant* other);

  // implements Message ----------------------------------------------

  MatchParticipant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchParticipant& from);
  void MergeFrom(const MatchParticipant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protobufs.UserStats user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::protobufs::UserStats& user() const;
  inline ::protobufs::UserStats* mutable_user();
  inline ::protobufs::UserStats* release_user();
  inline void set_allocated_user(::protobufs::UserStats* user);

  // optional .protobufs.Character character = 2;
  inline bool has_character() const;
  inline void clear_character();
  static const int kCharacterFieldNumber = 2;
  inline const ::protobufs::Character& character() const;
  inline ::protobufs::Character* mutable_character();
  inline ::protobufs::Character* release_character();
  inline void set_allocated_character(::protobufs::Character* character);

  // required int64 points_before = 3;
  inline bool has_points_before() const;
  inline void clear_points_before();
  static const int kPointsBeforeFieldNumber = 3;
  inline ::google::protobuf::int64 points_before() const;
  inline void set_points_before(::google::protobuf::int64 value);

  // required int64 points_after = 4;
  inline bool has_points_after() const;
  inline void clear_points_after();
  static const int kPointsAfterFieldNumber = 4;
  inline ::google::protobuf::int64 points_after() const;
  inline void set_points_after(::google::protobuf::int64 value);

  // required int64 points_difference = 5;
  inline bool has_points_difference() const;
  inline void clear_points_difference();
  static const int kPointsDifferenceFieldNumber = 5;
  inline ::google::protobuf::int64 points_difference() const;
  inline void set_points_difference(::google::protobuf::int64 value);

  // required bool victory = 6;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 6;
  inline bool victory() const;
  inline void set_victory(bool value);

  // required string race = 7;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 7;
  inline const ::std::string& race() const;
  inline void set_race(const ::std::string& value);
  inline void set_race(const char* value);
  inline void set_race(const char* value, size_t size);
  inline ::std::string* mutable_race();
  inline ::std::string* release_race();
  inline void set_allocated_race(::std::string* race);

  // @@protoc_insertion_point(class_scope:protobufs.MatchParticipant)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_character();
  inline void clear_has_character();
  inline void set_has_points_before();
  inline void clear_has_points_before();
  inline void set_has_points_after();
  inline void clear_has_points_after();
  inline void set_has_points_difference();
  inline void clear_has_points_difference();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_race();
  inline void clear_has_race();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::UserStats* user_;
  ::protobufs::Character* character_;
  ::google::protobuf::int64 points_before_;
  ::google::protobuf::int64 points_after_;
  ::google::protobuf::int64 points_difference_;
  ::std::string* race_;
  bool victory_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static MatchParticipant* default_instance_;
};
// -------------------------------------------------------------------

class MatchResult : public ::google::protobuf::Message {
 public:
  MatchResult();
  virtual ~MatchResult();

  MatchResult(const MatchResult& from);

  inline MatchResult& operator=(const MatchResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchResult& default_instance();

  void Swap(MatchResult* other);

  // implements Message ----------------------------------------------

  MatchResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchResult& from);
  void MergeFrom(const MatchResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobufs.Region region = 1;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 1;
  inline ::protobufs::Region region() const;
  inline void set_region(::protobufs::Region value);

  // required .protobufs.Map map = 2;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 2;
  inline const ::protobufs::Map& map() const;
  inline ::protobufs::Map* mutable_map();
  inline ::protobufs::Map* release_map();
  inline void set_allocated_map(::protobufs::Map* map);

  // repeated .protobufs.MatchParticipant participant = 3;
  inline int participant_size() const;
  inline void clear_participant();
  static const int kParticipantFieldNumber = 3;
  inline const ::protobufs::MatchParticipant& participant(int index) const;
  inline ::protobufs::MatchParticipant* mutable_participant(int index);
  inline ::protobufs::MatchParticipant* add_participant();
  inline const ::google::protobuf::RepeatedPtrField< ::protobufs::MatchParticipant >&
      participant() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobufs::MatchParticipant >*
      mutable_participant();

  // @@protoc_insertion_point(class_scope:protobufs.MatchResult)
 private:
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protobufs::Map* map_;
  ::google::protobuf::RepeatedPtrField< ::protobufs::MatchParticipant > participant_;
  int region_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static MatchResult* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastAlert : public ::google::protobuf::Message {
 public:
  BroadcastAlert();
  virtual ~BroadcastAlert();

  BroadcastAlert(const BroadcastAlert& from);

  inline BroadcastAlert& operator=(const BroadcastAlert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastAlert& default_instance();

  void Swap(BroadcastAlert* other);

  // implements Message ----------------------------------------------

  BroadcastAlert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastAlert& from);
  void MergeFrom(const BroadcastAlert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // required int32 predefined = 1;
  inline bool has_predefined() const;
  inline void clear_predefined();
  static const int kPredefinedFieldNumber = 1;
  inline ::google::protobuf::int32 predefined() const;
  inline void set_predefined(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protobufs.BroadcastAlert)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_predefined();
  inline void clear_has_predefined();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 predefined_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_eros_2eproto();
  friend void protobuf_AssignDesc_eros_2eproto();
  friend void protobuf_ShutdownFile_eros_2eproto();

  void InitAsDefaultInstance();
  static BroadcastAlert* default_instance_;
};
// ===================================================================


// ===================================================================

// Handshake

// optional string username = 1;
inline bool Handshake::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Handshake::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Handshake::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Handshake::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Handshake::username() const {
  return *username_;
}
inline void Handshake::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Handshake::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Handshake::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Handshake::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Handshake::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Handshake::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string auth_key = 2;
inline bool Handshake::has_auth_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Handshake::set_has_auth_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Handshake::clear_has_auth_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Handshake::clear_auth_key() {
  if (auth_key_ != &::google::protobuf::internal::kEmptyString) {
    auth_key_->clear();
  }
  clear_has_auth_key();
}
inline const ::std::string& Handshake::auth_key() const {
  return *auth_key_;
}
inline void Handshake::set_auth_key(const ::std::string& value) {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  auth_key_->assign(value);
}
inline void Handshake::set_auth_key(const char* value) {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  auth_key_->assign(value);
}
inline void Handshake::set_auth_key(const char* value, size_t size) {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  auth_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Handshake::mutable_auth_key() {
  set_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    auth_key_ = new ::std::string;
  }
  return auth_key_;
}
inline ::std::string* Handshake::release_auth_key() {
  clear_has_auth_key();
  if (auth_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_key_;
    auth_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Handshake::set_allocated_auth_key(::std::string* auth_key) {
  if (auth_key_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_key_;
  }
  if (auth_key) {
    set_has_auth_key();
    auth_key_ = auth_key;
  } else {
    clear_has_auth_key();
    auth_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Division

// required string name = 1;
inline bool Division::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Division::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Division::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Division::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Division::name() const {
  return *name_;
}
inline void Division::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Division::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Division::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Division::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Division::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Division::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 points = 2;
inline bool Division::has_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Division::set_has_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Division::clear_has_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Division::clear_points() {
  points_ = GOOGLE_LONGLONG(0);
  clear_has_points();
}
inline ::google::protobuf::int64 Division::points() const {
  return points_;
}
inline void Division::set_points(::google::protobuf::int64 value) {
  set_has_points();
  points_ = value;
}

// -------------------------------------------------------------------

// HandshakeResponse

// required .protobufs.HandshakeResponse.HandshakeStatus status = 1;
inline bool HandshakeResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HandshakeResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HandshakeResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HandshakeResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::protobufs::HandshakeResponse_HandshakeStatus HandshakeResponse::status() const {
  return static_cast< ::protobufs::HandshakeResponse_HandshakeStatus >(status_);
}
inline void HandshakeResponse::set_status(::protobufs::HandshakeResponse_HandshakeStatus value) {
  assert(::protobufs::HandshakeResponse_HandshakeStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .protobufs.UserStats user = 2;
inline bool HandshakeResponse::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HandshakeResponse::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HandshakeResponse::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HandshakeResponse::clear_user() {
  if (user_ != NULL) user_->::protobufs::UserStats::Clear();
  clear_has_user();
}
inline const ::protobufs::UserStats& HandshakeResponse::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::protobufs::UserStats* HandshakeResponse::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::protobufs::UserStats;
  return user_;
}
inline ::protobufs::UserStats* HandshakeResponse::release_user() {
  clear_has_user();
  ::protobufs::UserStats* temp = user_;
  user_ = NULL;
  return temp;
}
inline void HandshakeResponse::set_allocated_user(::protobufs::UserStats* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional int64 id = 3;
inline bool HandshakeResponse::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HandshakeResponse::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HandshakeResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HandshakeResponse::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 HandshakeResponse::id() const {
  return id_;
}
inline void HandshakeResponse::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// repeated .protobufs.Character character = 4;
inline int HandshakeResponse::character_size() const {
  return character_.size();
}
inline void HandshakeResponse::clear_character() {
  character_.Clear();
}
inline const ::protobufs::Character& HandshakeResponse::character(int index) const {
  return character_.Get(index);
}
inline ::protobufs::Character* HandshakeResponse::mutable_character(int index) {
  return character_.Mutable(index);
}
inline ::protobufs::Character* HandshakeResponse::add_character() {
  return character_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::Character >&
HandshakeResponse::character() const {
  return character_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::Character >*
HandshakeResponse::mutable_character() {
  return &character_;
}

// repeated .protobufs.Division division = 5;
inline int HandshakeResponse::division_size() const {
  return division_.size();
}
inline void HandshakeResponse::clear_division() {
  division_.Clear();
}
inline const ::protobufs::Division& HandshakeResponse::division(int index) const {
  return division_.Get(index);
}
inline ::protobufs::Division* HandshakeResponse::mutable_division(int index) {
  return division_.Mutable(index);
}
inline ::protobufs::Division* HandshakeResponse::add_division() {
  return division_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::Division >&
HandshakeResponse::division() const {
  return division_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::Division >*
HandshakeResponse::mutable_division() {
  return &division_;
}

// repeated .protobufs.Region active_region = 6;
inline int HandshakeResponse::active_region_size() const {
  return active_region_.size();
}
inline void HandshakeResponse::clear_active_region() {
  active_region_.Clear();
}
inline ::protobufs::Region HandshakeResponse::active_region(int index) const {
  return static_cast< ::protobufs::Region >(active_region_.Get(index));
}
inline void HandshakeResponse::set_active_region(int index, ::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  active_region_.Set(index, value);
}
inline void HandshakeResponse::add_active_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  active_region_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
HandshakeResponse::active_region() const {
  return active_region_;
}
inline ::google::protobuf::RepeatedField<int>*
HandshakeResponse::mutable_active_region() {
  return &active_region_;
}

// -------------------------------------------------------------------

// UserRegionStats

// required .protobufs.Region region = 1;
inline bool UserRegionStats::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRegionStats::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRegionStats::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRegionStats::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::protobufs::Region UserRegionStats::region() const {
  return static_cast< ::protobufs::Region >(region_);
}
inline void UserRegionStats::set_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// required int64 points = 2;
inline bool UserRegionStats::has_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRegionStats::set_has_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRegionStats::clear_has_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRegionStats::clear_points() {
  points_ = GOOGLE_LONGLONG(0);
  clear_has_points();
}
inline ::google::protobuf::int64 UserRegionStats::points() const {
  return points_;
}
inline void UserRegionStats::set_points(::google::protobuf::int64 value) {
  set_has_points();
  points_ = value;
}

// required int64 wins = 3;
inline bool UserRegionStats::has_wins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRegionStats::set_has_wins() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRegionStats::clear_has_wins() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRegionStats::clear_wins() {
  wins_ = GOOGLE_LONGLONG(0);
  clear_has_wins();
}
inline ::google::protobuf::int64 UserRegionStats::wins() const {
  return wins_;
}
inline void UserRegionStats::set_wins(::google::protobuf::int64 value) {
  set_has_wins();
  wins_ = value;
}

// required int64 losses = 4;
inline bool UserRegionStats::has_losses() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRegionStats::set_has_losses() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRegionStats::clear_has_losses() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRegionStats::clear_losses() {
  losses_ = GOOGLE_LONGLONG(0);
  clear_has_losses();
}
inline ::google::protobuf::int64 UserRegionStats::losses() const {
  return losses_;
}
inline void UserRegionStats::set_losses(::google::protobuf::int64 value) {
  set_has_losses();
  losses_ = value;
}

// required int64 forfeits = 5;
inline bool UserRegionStats::has_forfeits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserRegionStats::set_has_forfeits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserRegionStats::clear_has_forfeits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserRegionStats::clear_forfeits() {
  forfeits_ = GOOGLE_LONGLONG(0);
  clear_has_forfeits();
}
inline ::google::protobuf::int64 UserRegionStats::forfeits() const {
  return forfeits_;
}
inline void UserRegionStats::set_forfeits(::google::protobuf::int64 value) {
  set_has_forfeits();
  forfeits_ = value;
}

// required int64 walkovers = 6;
inline bool UserRegionStats::has_walkovers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserRegionStats::set_has_walkovers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserRegionStats::clear_has_walkovers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserRegionStats::clear_walkovers() {
  walkovers_ = GOOGLE_LONGLONG(0);
  clear_has_walkovers();
}
inline ::google::protobuf::int64 UserRegionStats::walkovers() const {
  return walkovers_;
}
inline void UserRegionStats::set_walkovers(::google::protobuf::int64 value) {
  set_has_walkovers();
  walkovers_ = value;
}

// -------------------------------------------------------------------

// UserStats

// required string username = 1;
inline bool UserStats::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStats::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStats::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStats::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& UserStats::username() const {
  return *username_;
}
inline void UserStats::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserStats::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserStats::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserStats::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* UserStats::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserStats::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 search_radius = 2;
inline bool UserStats::has_search_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStats::set_has_search_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStats::clear_has_search_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStats::clear_search_radius() {
  search_radius_ = GOOGLE_LONGLONG(0);
  clear_has_search_radius();
}
inline ::google::protobuf::int64 UserStats::search_radius() const {
  return search_radius_;
}
inline void UserStats::set_search_radius(::google::protobuf::int64 value) {
  set_has_search_radius();
  search_radius_ = value;
}

// required int64 points = 3;
inline bool UserStats::has_points() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStats::set_has_points() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStats::clear_has_points() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStats::clear_points() {
  points_ = GOOGLE_LONGLONG(0);
  clear_has_points();
}
inline ::google::protobuf::int64 UserStats::points() const {
  return points_;
}
inline void UserStats::set_points(::google::protobuf::int64 value) {
  set_has_points();
  points_ = value;
}

// required int64 wins = 4;
inline bool UserStats::has_wins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStats::set_has_wins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStats::clear_has_wins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStats::clear_wins() {
  wins_ = GOOGLE_LONGLONG(0);
  clear_has_wins();
}
inline ::google::protobuf::int64 UserStats::wins() const {
  return wins_;
}
inline void UserStats::set_wins(::google::protobuf::int64 value) {
  set_has_wins();
  wins_ = value;
}

// required int64 losses = 5;
inline bool UserStats::has_losses() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStats::set_has_losses() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStats::clear_has_losses() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStats::clear_losses() {
  losses_ = GOOGLE_LONGLONG(0);
  clear_has_losses();
}
inline ::google::protobuf::int64 UserStats::losses() const {
  return losses_;
}
inline void UserStats::set_losses(::google::protobuf::int64 value) {
  set_has_losses();
  losses_ = value;
}

// required int64 forfeits = 6;
inline bool UserStats::has_forfeits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStats::set_has_forfeits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStats::clear_has_forfeits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStats::clear_forfeits() {
  forfeits_ = GOOGLE_LONGLONG(0);
  clear_has_forfeits();
}
inline ::google::protobuf::int64 UserStats::forfeits() const {
  return forfeits_;
}
inline void UserStats::set_forfeits(::google::protobuf::int64 value) {
  set_has_forfeits();
  forfeits_ = value;
}

// required int64 walkovers = 7;
inline bool UserStats::has_walkovers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStats::set_has_walkovers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStats::clear_has_walkovers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStats::clear_walkovers() {
  walkovers_ = GOOGLE_LONGLONG(0);
  clear_has_walkovers();
}
inline ::google::protobuf::int64 UserStats::walkovers() const {
  return walkovers_;
}
inline void UserStats::set_walkovers(::google::protobuf::int64 value) {
  set_has_walkovers();
  walkovers_ = value;
}

// repeated .protobufs.UserRegionStats region = 8;
inline int UserStats::region_size() const {
  return region_.size();
}
inline void UserStats::clear_region() {
  region_.Clear();
}
inline const ::protobufs::UserRegionStats& UserStats::region(int index) const {
  return region_.Get(index);
}
inline ::protobufs::UserRegionStats* UserStats::mutable_region(int index) {
  return region_.Mutable(index);
}
inline ::protobufs::UserRegionStats* UserStats::add_region() {
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::UserRegionStats >&
UserStats::region() const {
  return region_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::UserRegionStats >*
UserStats::mutable_region() {
  return &region_;
}

// -------------------------------------------------------------------

// MapPool

// repeated .protobufs.Map map = 1;
inline int MapPool::map_size() const {
  return map_.size();
}
inline void MapPool::clear_map() {
  map_.Clear();
}
inline const ::protobufs::Map& MapPool::map(int index) const {
  return map_.Get(index);
}
inline ::protobufs::Map* MapPool::mutable_map(int index) {
  return map_.Mutable(index);
}
inline ::protobufs::Map* MapPool::add_map() {
  return map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::Map >&
MapPool::map() const {
  return map_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::Map >*
MapPool::mutable_map() {
  return &map_;
}

// -------------------------------------------------------------------

// Map

// required .protobufs.Region region = 1;
inline bool Map::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Map::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Map::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Map::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::protobufs::Region Map::region() const {
  return static_cast< ::protobufs::Region >(region_);
}
inline void Map::set_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// required string battle_net_name = 2;
inline bool Map::has_battle_net_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Map::set_has_battle_net_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Map::clear_has_battle_net_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Map::clear_battle_net_name() {
  if (battle_net_name_ != &::google::protobuf::internal::kEmptyString) {
    battle_net_name_->clear();
  }
  clear_has_battle_net_name();
}
inline const ::std::string& Map::battle_net_name() const {
  return *battle_net_name_;
}
inline void Map::set_battle_net_name(const ::std::string& value) {
  set_has_battle_net_name();
  if (battle_net_name_ == &::google::protobuf::internal::kEmptyString) {
    battle_net_name_ = new ::std::string;
  }
  battle_net_name_->assign(value);
}
inline void Map::set_battle_net_name(const char* value) {
  set_has_battle_net_name();
  if (battle_net_name_ == &::google::protobuf::internal::kEmptyString) {
    battle_net_name_ = new ::std::string;
  }
  battle_net_name_->assign(value);
}
inline void Map::set_battle_net_name(const char* value, size_t size) {
  set_has_battle_net_name();
  if (battle_net_name_ == &::google::protobuf::internal::kEmptyString) {
    battle_net_name_ = new ::std::string;
  }
  battle_net_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Map::mutable_battle_net_name() {
  set_has_battle_net_name();
  if (battle_net_name_ == &::google::protobuf::internal::kEmptyString) {
    battle_net_name_ = new ::std::string;
  }
  return battle_net_name_;
}
inline ::std::string* Map::release_battle_net_name() {
  clear_has_battle_net_name();
  if (battle_net_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battle_net_name_;
    battle_net_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Map::set_allocated_battle_net_name(::std::string* battle_net_name) {
  if (battle_net_name_ != &::google::protobuf::internal::kEmptyString) {
    delete battle_net_name_;
  }
  if (battle_net_name) {
    set_has_battle_net_name();
    battle_net_name_ = battle_net_name;
  } else {
    clear_has_battle_net_name();
    battle_net_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 battle_net_id = 3;
inline bool Map::has_battle_net_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Map::set_has_battle_net_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Map::clear_has_battle_net_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Map::clear_battle_net_id() {
  battle_net_id_ = 0;
  clear_has_battle_net_id();
}
inline ::google::protobuf::int32 Map::battle_net_id() const {
  return battle_net_id_;
}
inline void Map::set_battle_net_id(::google::protobuf::int32 value) {
  set_has_battle_net_id();
  battle_net_id_ = value;
}

// -------------------------------------------------------------------

// SimulationResult

// required .protobufs.UserStats opponent = 1;
inline bool SimulationResult::has_opponent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulationResult::set_has_opponent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulationResult::clear_has_opponent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimulationResult::clear_opponent() {
  if (opponent_ != NULL) opponent_->::protobufs::UserStats::Clear();
  clear_has_opponent();
}
inline const ::protobufs::UserStats& SimulationResult::opponent() const {
  return opponent_ != NULL ? *opponent_ : *default_instance_->opponent_;
}
inline ::protobufs::UserStats* SimulationResult::mutable_opponent() {
  set_has_opponent();
  if (opponent_ == NULL) opponent_ = new ::protobufs::UserStats;
  return opponent_;
}
inline ::protobufs::UserStats* SimulationResult::release_opponent() {
  clear_has_opponent();
  ::protobufs::UserStats* temp = opponent_;
  opponent_ = NULL;
  return temp;
}
inline void SimulationResult::set_allocated_opponent(::protobufs::UserStats* opponent) {
  delete opponent_;
  opponent_ = opponent;
  if (opponent) {
    set_has_opponent();
  } else {
    clear_has_opponent();
  }
}

// required bool victory = 2;
inline bool SimulationResult::has_victory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulationResult::set_has_victory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulationResult::clear_has_victory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulationResult::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool SimulationResult::victory() const {
  return victory_;
}
inline void SimulationResult::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// required double match_quality = 3;
inline bool SimulationResult::has_match_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulationResult::set_has_match_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulationResult::clear_has_match_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulationResult::clear_match_quality() {
  match_quality_ = 0;
  clear_has_match_quality();
}
inline double SimulationResult::match_quality() const {
  return match_quality_;
}
inline void SimulationResult::set_match_quality(double value) {
  set_has_match_quality();
  match_quality_ = value;
}

// -------------------------------------------------------------------

// MatchmakingQueue

// required .protobufs.Region region = 1;
inline bool MatchmakingQueue::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchmakingQueue::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchmakingQueue::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchmakingQueue::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::protobufs::Region MatchmakingQueue::region() const {
  return static_cast< ::protobufs::Region >(region_);
}
inline void MatchmakingQueue::set_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// required int64 radius = 2;
inline bool MatchmakingQueue::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchmakingQueue::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchmakingQueue::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchmakingQueue::clear_radius() {
  radius_ = GOOGLE_LONGLONG(0);
  clear_has_radius();
}
inline ::google::protobuf::int64 MatchmakingQueue::radius() const {
  return radius_;
}
inline void MatchmakingQueue::set_radius(::google::protobuf::int64 value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// MatchmakingResult

// required int64 timespan = 1;
inline bool MatchmakingResult::has_timespan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchmakingResult::set_has_timespan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchmakingResult::clear_has_timespan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchmakingResult::clear_timespan() {
  timespan_ = GOOGLE_LONGLONG(0);
  clear_has_timespan();
}
inline ::google::protobuf::int64 MatchmakingResult::timespan() const {
  return timespan_;
}
inline void MatchmakingResult::set_timespan(::google::protobuf::int64 value) {
  set_has_timespan();
  timespan_ = value;
}

// required double quality = 2;
inline bool MatchmakingResult::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchmakingResult::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchmakingResult::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchmakingResult::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double MatchmakingResult::quality() const {
  return quality_;
}
inline void MatchmakingResult::set_quality(double value) {
  set_has_quality();
  quality_ = value;
}

// required .protobufs.UserStats opponent = 3;
inline bool MatchmakingResult::has_opponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchmakingResult::set_has_opponent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchmakingResult::clear_has_opponent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchmakingResult::clear_opponent() {
  if (opponent_ != NULL) opponent_->::protobufs::UserStats::Clear();
  clear_has_opponent();
}
inline const ::protobufs::UserStats& MatchmakingResult::opponent() const {
  return opponent_ != NULL ? *opponent_ : *default_instance_->opponent_;
}
inline ::protobufs::UserStats* MatchmakingResult::mutable_opponent() {
  set_has_opponent();
  if (opponent_ == NULL) opponent_ = new ::protobufs::UserStats;
  return opponent_;
}
inline ::protobufs::UserStats* MatchmakingResult::release_opponent() {
  clear_has_opponent();
  ::protobufs::UserStats* temp = opponent_;
  opponent_ = NULL;
  return temp;
}
inline void MatchmakingResult::set_allocated_opponent(::protobufs::UserStats* opponent) {
  delete opponent_;
  opponent_ = opponent;
  if (opponent) {
    set_has_opponent();
  } else {
    clear_has_opponent();
  }
}

// required int64 opponent_latency = 4;
inline bool MatchmakingResult::has_opponent_latency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchmakingResult::set_has_opponent_latency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchmakingResult::clear_has_opponent_latency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchmakingResult::clear_opponent_latency() {
  opponent_latency_ = GOOGLE_LONGLONG(0);
  clear_has_opponent_latency();
}
inline ::google::protobuf::int64 MatchmakingResult::opponent_latency() const {
  return opponent_latency_;
}
inline void MatchmakingResult::set_opponent_latency(::google::protobuf::int64 value) {
  set_has_opponent_latency();
  opponent_latency_ = value;
}

// required string channel = 5;
inline bool MatchmakingResult::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchmakingResult::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchmakingResult::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchmakingResult::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& MatchmakingResult::channel() const {
  return *channel_;
}
inline void MatchmakingResult::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void MatchmakingResult::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void MatchmakingResult::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchmakingResult::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* MatchmakingResult::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchmakingResult::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string chat_room = 6;
inline bool MatchmakingResult::has_chat_room() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatchmakingResult::set_has_chat_room() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatchmakingResult::clear_has_chat_room() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatchmakingResult::clear_chat_room() {
  if (chat_room_ != &::google::protobuf::internal::kEmptyString) {
    chat_room_->clear();
  }
  clear_has_chat_room();
}
inline const ::std::string& MatchmakingResult::chat_room() const {
  return *chat_room_;
}
inline void MatchmakingResult::set_chat_room(const ::std::string& value) {
  set_has_chat_room();
  if (chat_room_ == &::google::protobuf::internal::kEmptyString) {
    chat_room_ = new ::std::string;
  }
  chat_room_->assign(value);
}
inline void MatchmakingResult::set_chat_room(const char* value) {
  set_has_chat_room();
  if (chat_room_ == &::google::protobuf::internal::kEmptyString) {
    chat_room_ = new ::std::string;
  }
  chat_room_->assign(value);
}
inline void MatchmakingResult::set_chat_room(const char* value, size_t size) {
  set_has_chat_room();
  if (chat_room_ == &::google::protobuf::internal::kEmptyString) {
    chat_room_ = new ::std::string;
  }
  chat_room_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchmakingResult::mutable_chat_room() {
  set_has_chat_room();
  if (chat_room_ == &::google::protobuf::internal::kEmptyString) {
    chat_room_ = new ::std::string;
  }
  return chat_room_;
}
inline ::std::string* MatchmakingResult::release_chat_room() {
  clear_has_chat_room();
  if (chat_room_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_room_;
    chat_room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchmakingResult::set_allocated_chat_room(::std::string* chat_room) {
  if (chat_room_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_room_;
  }
  if (chat_room) {
    set_has_chat_room();
    chat_room_ = chat_room;
  } else {
    clear_has_chat_room();
    chat_room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .protobufs.Map map = 7;
inline bool MatchmakingResult::has_map() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MatchmakingResult::set_has_map() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MatchmakingResult::clear_has_map() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MatchmakingResult::clear_map() {
  if (map_ != NULL) map_->::protobufs::Map::Clear();
  clear_has_map();
}
inline const ::protobufs::Map& MatchmakingResult::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::protobufs::Map* MatchmakingResult::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::protobufs::Map;
  return map_;
}
inline ::protobufs::Map* MatchmakingResult::release_map() {
  clear_has_map();
  ::protobufs::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void MatchmakingResult::set_allocated_map(::protobufs::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// required int64 long_unlock_time = 8;
inline bool MatchmakingResult::has_long_unlock_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MatchmakingResult::set_has_long_unlock_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MatchmakingResult::clear_has_long_unlock_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MatchmakingResult::clear_long_unlock_time() {
  long_unlock_time_ = GOOGLE_LONGLONG(0);
  clear_has_long_unlock_time();
}
inline ::google::protobuf::int64 MatchmakingResult::long_unlock_time() const {
  return long_unlock_time_;
}
inline void MatchmakingResult::set_long_unlock_time(::google::protobuf::int64 value) {
  set_has_long_unlock_time();
  long_unlock_time_ = value;
}

// required int64 long_response_time = 9;
inline bool MatchmakingResult::has_long_response_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MatchmakingResult::set_has_long_response_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MatchmakingResult::clear_has_long_response_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MatchmakingResult::clear_long_response_time() {
  long_response_time_ = GOOGLE_LONGLONG(0);
  clear_has_long_response_time();
}
inline ::google::protobuf::int64 MatchmakingResult::long_response_time() const {
  return long_response_time_;
}
inline void MatchmakingResult::set_long_response_time(::google::protobuf::int64 value) {
  set_has_long_response_time();
  long_response_time_ = value;
}

// -------------------------------------------------------------------

// ChatRoomInfo

// required string key = 1;
inline bool ChatRoomInfo::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRoomInfo::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRoomInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRoomInfo::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ChatRoomInfo::key() const {
  return *key_;
}
inline void ChatRoomInfo::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ChatRoomInfo::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ChatRoomInfo::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRoomInfo::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ChatRoomInfo::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRoomInfo::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool ChatRoomInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRoomInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRoomInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRoomInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChatRoomInfo::name() const {
  return *name_;
}
inline void ChatRoomInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChatRoomInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChatRoomInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRoomInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ChatRoomInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRoomInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool passworded = 3;
inline bool ChatRoomInfo::has_passworded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatRoomInfo::set_has_passworded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatRoomInfo::clear_has_passworded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatRoomInfo::clear_passworded() {
  passworded_ = false;
  clear_has_passworded();
}
inline bool ChatRoomInfo::passworded() const {
  return passworded_;
}
inline void ChatRoomInfo::set_passworded(bool value) {
  set_has_passworded();
  passworded_ = value;
}

// required bool joinable = 4;
inline bool ChatRoomInfo::has_joinable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatRoomInfo::set_has_joinable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatRoomInfo::clear_has_joinable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatRoomInfo::clear_joinable() {
  joinable_ = false;
  clear_has_joinable();
}
inline bool ChatRoomInfo::joinable() const {
  return joinable_;
}
inline void ChatRoomInfo::set_joinable(bool value) {
  set_has_joinable();
  joinable_ = value;
}

// required bool fixed = 5;
inline bool ChatRoomInfo::has_fixed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatRoomInfo::set_has_fixed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatRoomInfo::clear_has_fixed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatRoomInfo::clear_fixed() {
  fixed_ = false;
  clear_has_fixed();
}
inline bool ChatRoomInfo::fixed() const {
  return fixed_;
}
inline void ChatRoomInfo::set_fixed(bool value) {
  set_has_fixed();
  fixed_ = value;
}

// required int64 users = 6;
inline bool ChatRoomInfo::has_users() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChatRoomInfo::set_has_users() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChatRoomInfo::clear_has_users() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChatRoomInfo::clear_users() {
  users_ = GOOGLE_LONGLONG(0);
  clear_has_users();
}
inline ::google::protobuf::int64 ChatRoomInfo::users() const {
  return users_;
}
inline void ChatRoomInfo::set_users(::google::protobuf::int64 value) {
  set_has_users();
  users_ = value;
}

// repeated .protobufs.UserStats participant = 7;
inline int ChatRoomInfo::participant_size() const {
  return participant_.size();
}
inline void ChatRoomInfo::clear_participant() {
  participant_.Clear();
}
inline const ::protobufs::UserStats& ChatRoomInfo::participant(int index) const {
  return participant_.Get(index);
}
inline ::protobufs::UserStats* ChatRoomInfo::mutable_participant(int index) {
  return participant_.Mutable(index);
}
inline ::protobufs::UserStats* ChatRoomInfo::add_participant() {
  return participant_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::UserStats >&
ChatRoomInfo::participant() const {
  return participant_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::UserStats >*
ChatRoomInfo::mutable_participant() {
  return &participant_;
}

// -------------------------------------------------------------------

// ChatRoomIndex

// repeated .protobufs.ChatRoomInfo room = 1;
inline int ChatRoomIndex::room_size() const {
  return room_.size();
}
inline void ChatRoomIndex::clear_room() {
  room_.Clear();
}
inline const ::protobufs::ChatRoomInfo& ChatRoomIndex::room(int index) const {
  return room_.Get(index);
}
inline ::protobufs::ChatRoomInfo* ChatRoomIndex::mutable_room(int index) {
  return room_.Mutable(index);
}
inline ::protobufs::ChatRoomInfo* ChatRoomIndex::add_room() {
  return room_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::ChatRoomInfo >&
ChatRoomIndex::room() const {
  return room_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::ChatRoomInfo >*
ChatRoomIndex::mutable_room() {
  return &room_;
}

// -------------------------------------------------------------------

// ChatMessage

// required string sender = 1;
inline bool ChatMessage::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatMessage::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatMessage::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatMessage::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& ChatMessage::sender() const {
  return *sender_;
}
inline void ChatMessage::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ChatMessage::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ChatMessage::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMessage::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* ChatMessage::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatMessage::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string target = 2;
inline bool ChatMessage::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatMessage::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatMessage::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatMessage::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& ChatMessage::target() const {
  return *target_;
}
inline void ChatMessage::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void ChatMessage::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void ChatMessage::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMessage::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* ChatMessage::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatMessage::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string message = 3;
inline bool ChatMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ChatMessage::message() const {
  return *message_;
}
inline void ChatMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ChatMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatRoomMessage

// required .protobufs.ChatRoomInfo room = 1;
inline bool ChatRoomMessage::has_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRoomMessage::set_has_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRoomMessage::clear_has_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRoomMessage::clear_room() {
  if (room_ != NULL) room_->::protobufs::ChatRoomInfo::Clear();
  clear_has_room();
}
inline const ::protobufs::ChatRoomInfo& ChatRoomMessage::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::protobufs::ChatRoomInfo* ChatRoomMessage::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::protobufs::ChatRoomInfo;
  return room_;
}
inline ::protobufs::ChatRoomInfo* ChatRoomMessage::release_room() {
  clear_has_room();
  ::protobufs::ChatRoomInfo* temp = room_;
  room_ = NULL;
  return temp;
}
inline void ChatRoomMessage::set_allocated_room(::protobufs::ChatRoomInfo* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// required .protobufs.UserStats sender = 2;
inline bool ChatRoomMessage::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRoomMessage::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRoomMessage::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRoomMessage::clear_sender() {
  if (sender_ != NULL) sender_->::protobufs::UserStats::Clear();
  clear_has_sender();
}
inline const ::protobufs::UserStats& ChatRoomMessage::sender() const {
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::protobufs::UserStats* ChatRoomMessage::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::protobufs::UserStats;
  return sender_;
}
inline ::protobufs::UserStats* ChatRoomMessage::release_sender() {
  clear_has_sender();
  ::protobufs::UserStats* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void ChatRoomMessage::set_allocated_sender(::protobufs::UserStats* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
}

// required string message = 3;
inline bool ChatRoomMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatRoomMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatRoomMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatRoomMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ChatRoomMessage::message() const {
  return *message_;
}
inline void ChatRoomMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatRoomMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatRoomMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRoomMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ChatRoomMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRoomMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatPrivateMessage

// required .protobufs.UserStats sender = 1;
inline bool ChatPrivateMessage::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatPrivateMessage::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatPrivateMessage::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatPrivateMessage::clear_sender() {
  if (sender_ != NULL) sender_->::protobufs::UserStats::Clear();
  clear_has_sender();
}
inline const ::protobufs::UserStats& ChatPrivateMessage::sender() const {
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::protobufs::UserStats* ChatPrivateMessage::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::protobufs::UserStats;
  return sender_;
}
inline ::protobufs::UserStats* ChatPrivateMessage::release_sender() {
  clear_has_sender();
  ::protobufs::UserStats* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void ChatPrivateMessage::set_allocated_sender(::protobufs::UserStats* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
}

// required string message = 2;
inline bool ChatPrivateMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatPrivateMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatPrivateMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatPrivateMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ChatPrivateMessage::message() const {
  return *message_;
}
inline void ChatPrivateMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatPrivateMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatPrivateMessage::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatPrivateMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ChatPrivateMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatPrivateMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatRoomUser

// required .protobufs.ChatRoomInfo room = 1;
inline bool ChatRoomUser::has_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRoomUser::set_has_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRoomUser::clear_has_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRoomUser::clear_room() {
  if (room_ != NULL) room_->::protobufs::ChatRoomInfo::Clear();
  clear_has_room();
}
inline const ::protobufs::ChatRoomInfo& ChatRoomUser::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::protobufs::ChatRoomInfo* ChatRoomUser::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::protobufs::ChatRoomInfo;
  return room_;
}
inline ::protobufs::ChatRoomInfo* ChatRoomUser::release_room() {
  clear_has_room();
  ::protobufs::ChatRoomInfo* temp = room_;
  room_ = NULL;
  return temp;
}
inline void ChatRoomUser::set_allocated_room(::protobufs::ChatRoomInfo* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// required .protobufs.UserStats user = 2;
inline bool ChatRoomUser::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRoomUser::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRoomUser::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRoomUser::clear_user() {
  if (user_ != NULL) user_->::protobufs::UserStats::Clear();
  clear_has_user();
}
inline const ::protobufs::UserStats& ChatRoomUser::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::protobufs::UserStats* ChatRoomUser::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::protobufs::UserStats;
  return user_;
}
inline ::protobufs::UserStats* ChatRoomUser::release_user() {
  clear_has_user();
  ::protobufs::UserStats* temp = user_;
  user_ = NULL;
  return temp;
}
inline void ChatRoomUser::set_allocated_user(::protobufs::UserStats* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// -------------------------------------------------------------------

// ChatRoomRequest

// required string room = 1;
inline bool ChatRoomRequest::has_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRoomRequest::set_has_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRoomRequest::clear_has_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRoomRequest::clear_room() {
  if (room_ != &::google::protobuf::internal::kEmptyString) {
    room_->clear();
  }
  clear_has_room();
}
inline const ::std::string& ChatRoomRequest::room() const {
  return *room_;
}
inline void ChatRoomRequest::set_room(const ::std::string& value) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(value);
}
inline void ChatRoomRequest::set_room(const char* value) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(value);
}
inline void ChatRoomRequest::set_room(const char* value, size_t size) {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  room_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRoomRequest::mutable_room() {
  set_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    room_ = new ::std::string;
  }
  return room_;
}
inline ::std::string* ChatRoomRequest::release_room() {
  clear_has_room();
  if (room_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = room_;
    room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRoomRequest::set_allocated_room(::std::string* room) {
  if (room_ != &::google::protobuf::internal::kEmptyString) {
    delete room_;
  }
  if (room) {
    set_has_room();
    room_ = room;
  } else {
    clear_has_room();
    room_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool ChatRoomRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRoomRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRoomRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRoomRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ChatRoomRequest::password() const {
  return *password_;
}
inline void ChatRoomRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ChatRoomRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ChatRoomRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRoomRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ChatRoomRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRoomRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MatchmakingStats

// required .protobufs.Region region = 1;
inline bool MatchmakingStats::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchmakingStats::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchmakingStats::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchmakingStats::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::protobufs::Region MatchmakingStats::region() const {
  return static_cast< ::protobufs::Region >(region_);
}
inline void MatchmakingStats::set_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// required int64 searching_users = 2;
inline bool MatchmakingStats::has_searching_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchmakingStats::set_has_searching_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchmakingStats::clear_has_searching_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchmakingStats::clear_searching_users() {
  searching_users_ = GOOGLE_LONGLONG(0);
  clear_has_searching_users();
}
inline ::google::protobuf::int64 MatchmakingStats::searching_users() const {
  return searching_users_;
}
inline void MatchmakingStats::set_searching_users(::google::protobuf::int64 value) {
  set_has_searching_users();
  searching_users_ = value;
}

// -------------------------------------------------------------------

// ServerStats

// required int64 active_users = 1;
inline bool ServerStats::has_active_users() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerStats::set_has_active_users() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerStats::clear_has_active_users() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerStats::clear_active_users() {
  active_users_ = GOOGLE_LONGLONG(0);
  clear_has_active_users();
}
inline ::google::protobuf::int64 ServerStats::active_users() const {
  return active_users_;
}
inline void ServerStats::set_active_users(::google::protobuf::int64 value) {
  set_has_active_users();
  active_users_ = value;
}

// required int64 searching_users = 2;
inline bool ServerStats::has_searching_users() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerStats::set_has_searching_users() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerStats::clear_has_searching_users() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerStats::clear_searching_users() {
  searching_users_ = GOOGLE_LONGLONG(0);
  clear_has_searching_users();
}
inline ::google::protobuf::int64 ServerStats::searching_users() const {
  return searching_users_;
}
inline void ServerStats::set_searching_users(::google::protobuf::int64 value) {
  set_has_searching_users();
  searching_users_ = value;
}

// repeated .protobufs.MatchmakingStats region = 3;
inline int ServerStats::region_size() const {
  return region_.size();
}
inline void ServerStats::clear_region() {
  region_.Clear();
}
inline const ::protobufs::MatchmakingStats& ServerStats::region(int index) const {
  return region_.Get(index);
}
inline ::protobufs::MatchmakingStats* ServerStats::mutable_region(int index) {
  return region_.Mutable(index);
}
inline ::protobufs::MatchmakingStats* ServerStats::add_region() {
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::MatchmakingStats >&
ServerStats::region() const {
  return region_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::MatchmakingStats >*
ServerStats::mutable_region() {
  return &region_;
}

// -------------------------------------------------------------------

// Character

// required .protobufs.Region region = 1;
inline bool Character::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Character::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Character::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Character::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::protobufs::Region Character::region() const {
  return static_cast< ::protobufs::Region >(region_);
}
inline void Character::set_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// required int32 subregion = 2;
inline bool Character::has_subregion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Character::set_has_subregion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Character::clear_has_subregion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Character::clear_subregion() {
  subregion_ = 0;
  clear_has_subregion();
}
inline ::google::protobuf::int32 Character::subregion() const {
  return subregion_;
}
inline void Character::set_subregion(::google::protobuf::int32 value) {
  set_has_subregion();
  subregion_ = value;
}

// required int32 profile_id = 3;
inline bool Character::has_profile_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Character::set_has_profile_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Character::clear_has_profile_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Character::clear_profile_id() {
  profile_id_ = 0;
  clear_has_profile_id();
}
inline ::google::protobuf::int32 Character::profile_id() const {
  return profile_id_;
}
inline void Character::set_profile_id(::google::protobuf::int32 value) {
  set_has_profile_id();
  profile_id_ = value;
}

// required string character_name = 4;
inline bool Character::has_character_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Character::set_has_character_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Character::clear_has_character_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Character::clear_character_name() {
  if (character_name_ != &::google::protobuf::internal::kEmptyString) {
    character_name_->clear();
  }
  clear_has_character_name();
}
inline const ::std::string& Character::character_name() const {
  return *character_name_;
}
inline void Character::set_character_name(const ::std::string& value) {
  set_has_character_name();
  if (character_name_ == &::google::protobuf::internal::kEmptyString) {
    character_name_ = new ::std::string;
  }
  character_name_->assign(value);
}
inline void Character::set_character_name(const char* value) {
  set_has_character_name();
  if (character_name_ == &::google::protobuf::internal::kEmptyString) {
    character_name_ = new ::std::string;
  }
  character_name_->assign(value);
}
inline void Character::set_character_name(const char* value, size_t size) {
  set_has_character_name();
  if (character_name_ == &::google::protobuf::internal::kEmptyString) {
    character_name_ = new ::std::string;
  }
  character_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Character::mutable_character_name() {
  set_has_character_name();
  if (character_name_ == &::google::protobuf::internal::kEmptyString) {
    character_name_ = new ::std::string;
  }
  return character_name_;
}
inline ::std::string* Character::release_character_name() {
  clear_has_character_name();
  if (character_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = character_name_;
    character_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Character::set_allocated_character_name(::std::string* character_name) {
  if (character_name_ != &::google::protobuf::internal::kEmptyString) {
    delete character_name_;
  }
  if (character_name) {
    set_has_character_name();
    character_name_ = character_name;
  } else {
    clear_has_character_name();
    character_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 character_code = 5;
inline bool Character::has_character_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Character::set_has_character_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Character::clear_has_character_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Character::clear_character_code() {
  character_code_ = 0;
  clear_has_character_code();
}
inline ::google::protobuf::int32 Character::character_code() const {
  return character_code_;
}
inline void Character::set_character_code(::google::protobuf::int32 value) {
  set_has_character_code();
  character_code_ = value;
}

// optional string profile_link = 6;
inline bool Character::has_profile_link() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Character::set_has_profile_link() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Character::clear_has_profile_link() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Character::clear_profile_link() {
  if (profile_link_ != &::google::protobuf::internal::kEmptyString) {
    profile_link_->clear();
  }
  clear_has_profile_link();
}
inline const ::std::string& Character::profile_link() const {
  return *profile_link_;
}
inline void Character::set_profile_link(const ::std::string& value) {
  set_has_profile_link();
  if (profile_link_ == &::google::protobuf::internal::kEmptyString) {
    profile_link_ = new ::std::string;
  }
  profile_link_->assign(value);
}
inline void Character::set_profile_link(const char* value) {
  set_has_profile_link();
  if (profile_link_ == &::google::protobuf::internal::kEmptyString) {
    profile_link_ = new ::std::string;
  }
  profile_link_->assign(value);
}
inline void Character::set_profile_link(const char* value, size_t size) {
  set_has_profile_link();
  if (profile_link_ == &::google::protobuf::internal::kEmptyString) {
    profile_link_ = new ::std::string;
  }
  profile_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Character::mutable_profile_link() {
  set_has_profile_link();
  if (profile_link_ == &::google::protobuf::internal::kEmptyString) {
    profile_link_ = new ::std::string;
  }
  return profile_link_;
}
inline ::std::string* Character::release_profile_link() {
  clear_has_profile_link();
  if (profile_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profile_link_;
    profile_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Character::set_allocated_profile_link(::std::string* profile_link) {
  if (profile_link_ != &::google::protobuf::internal::kEmptyString) {
    delete profile_link_;
  }
  if (profile_link) {
    set_has_profile_link();
    profile_link_ = profile_link;
  } else {
    clear_has_profile_link();
    profile_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ingame_profile_link = 7;
inline bool Character::has_ingame_profile_link() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Character::set_has_ingame_profile_link() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Character::clear_has_ingame_profile_link() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Character::clear_ingame_profile_link() {
  if (ingame_profile_link_ != &::google::protobuf::internal::kEmptyString) {
    ingame_profile_link_->clear();
  }
  clear_has_ingame_profile_link();
}
inline const ::std::string& Character::ingame_profile_link() const {
  return *ingame_profile_link_;
}
inline void Character::set_ingame_profile_link(const ::std::string& value) {
  set_has_ingame_profile_link();
  if (ingame_profile_link_ == &::google::protobuf::internal::kEmptyString) {
    ingame_profile_link_ = new ::std::string;
  }
  ingame_profile_link_->assign(value);
}
inline void Character::set_ingame_profile_link(const char* value) {
  set_has_ingame_profile_link();
  if (ingame_profile_link_ == &::google::protobuf::internal::kEmptyString) {
    ingame_profile_link_ = new ::std::string;
  }
  ingame_profile_link_->assign(value);
}
inline void Character::set_ingame_profile_link(const char* value, size_t size) {
  set_has_ingame_profile_link();
  if (ingame_profile_link_ == &::google::protobuf::internal::kEmptyString) {
    ingame_profile_link_ = new ::std::string;
  }
  ingame_profile_link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Character::mutable_ingame_profile_link() {
  set_has_ingame_profile_link();
  if (ingame_profile_link_ == &::google::protobuf::internal::kEmptyString) {
    ingame_profile_link_ = new ::std::string;
  }
  return ingame_profile_link_;
}
inline ::std::string* Character::release_ingame_profile_link() {
  clear_has_ingame_profile_link();
  if (ingame_profile_link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ingame_profile_link_;
    ingame_profile_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Character::set_allocated_ingame_profile_link(::std::string* ingame_profile_link) {
  if (ingame_profile_link_ != &::google::protobuf::internal::kEmptyString) {
    delete ingame_profile_link_;
  }
  if (ingame_profile_link) {
    set_has_ingame_profile_link();
    ingame_profile_link_ = ingame_profile_link;
  } else {
    clear_has_ingame_profile_link();
    ingame_profile_link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool verified = 8;
inline bool Character::has_verified() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Character::set_has_verified() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Character::clear_has_verified() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Character::clear_verified() {
  verified_ = false;
  clear_has_verified();
}
inline bool Character::verified() const {
  return verified_;
}
inline void Character::set_verified(bool value) {
  set_has_verified();
  verified_ = value;
}

// optional int32 verification_portrait = 9;
inline bool Character::has_verification_portrait() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Character::set_has_verification_portrait() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Character::clear_has_verification_portrait() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Character::clear_verification_portrait() {
  verification_portrait_ = 0;
  clear_has_verification_portrait();
}
inline ::google::protobuf::int32 Character::verification_portrait() const {
  return verification_portrait_;
}
inline void Character::set_verification_portrait(::google::protobuf::int32 value) {
  set_has_verification_portrait();
  verification_portrait_ = value;
}

// -------------------------------------------------------------------

// MatchParticipant

// optional .protobufs.UserStats user = 1;
inline bool MatchParticipant::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchParticipant::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchParticipant::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchParticipant::clear_user() {
  if (user_ != NULL) user_->::protobufs::UserStats::Clear();
  clear_has_user();
}
inline const ::protobufs::UserStats& MatchParticipant::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::protobufs::UserStats* MatchParticipant::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::protobufs::UserStats;
  return user_;
}
inline ::protobufs::UserStats* MatchParticipant::release_user() {
  clear_has_user();
  ::protobufs::UserStats* temp = user_;
  user_ = NULL;
  return temp;
}
inline void MatchParticipant::set_allocated_user(::protobufs::UserStats* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional .protobufs.Character character = 2;
inline bool MatchParticipant::has_character() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchParticipant::set_has_character() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchParticipant::clear_has_character() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchParticipant::clear_character() {
  if (character_ != NULL) character_->::protobufs::Character::Clear();
  clear_has_character();
}
inline const ::protobufs::Character& MatchParticipant::character() const {
  return character_ != NULL ? *character_ : *default_instance_->character_;
}
inline ::protobufs::Character* MatchParticipant::mutable_character() {
  set_has_character();
  if (character_ == NULL) character_ = new ::protobufs::Character;
  return character_;
}
inline ::protobufs::Character* MatchParticipant::release_character() {
  clear_has_character();
  ::protobufs::Character* temp = character_;
  character_ = NULL;
  return temp;
}
inline void MatchParticipant::set_allocated_character(::protobufs::Character* character) {
  delete character_;
  character_ = character;
  if (character) {
    set_has_character();
  } else {
    clear_has_character();
  }
}

// required int64 points_before = 3;
inline bool MatchParticipant::has_points_before() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchParticipant::set_has_points_before() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchParticipant::clear_has_points_before() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchParticipant::clear_points_before() {
  points_before_ = GOOGLE_LONGLONG(0);
  clear_has_points_before();
}
inline ::google::protobuf::int64 MatchParticipant::points_before() const {
  return points_before_;
}
inline void MatchParticipant::set_points_before(::google::protobuf::int64 value) {
  set_has_points_before();
  points_before_ = value;
}

// required int64 points_after = 4;
inline bool MatchParticipant::has_points_after() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchParticipant::set_has_points_after() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchParticipant::clear_has_points_after() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchParticipant::clear_points_after() {
  points_after_ = GOOGLE_LONGLONG(0);
  clear_has_points_after();
}
inline ::google::protobuf::int64 MatchParticipant::points_after() const {
  return points_after_;
}
inline void MatchParticipant::set_points_after(::google::protobuf::int64 value) {
  set_has_points_after();
  points_after_ = value;
}

// required int64 points_difference = 5;
inline bool MatchParticipant::has_points_difference() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchParticipant::set_has_points_difference() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchParticipant::clear_has_points_difference() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchParticipant::clear_points_difference() {
  points_difference_ = GOOGLE_LONGLONG(0);
  clear_has_points_difference();
}
inline ::google::protobuf::int64 MatchParticipant::points_difference() const {
  return points_difference_;
}
inline void MatchParticipant::set_points_difference(::google::protobuf::int64 value) {
  set_has_points_difference();
  points_difference_ = value;
}

// required bool victory = 6;
inline bool MatchParticipant::has_victory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatchParticipant::set_has_victory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatchParticipant::clear_has_victory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatchParticipant::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool MatchParticipant::victory() const {
  return victory_;
}
inline void MatchParticipant::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// required string race = 7;
inline bool MatchParticipant::has_race() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MatchParticipant::set_has_race() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MatchParticipant::clear_has_race() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MatchParticipant::clear_race() {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    race_->clear();
  }
  clear_has_race();
}
inline const ::std::string& MatchParticipant::race() const {
  return *race_;
}
inline void MatchParticipant::set_race(const ::std::string& value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void MatchParticipant::set_race(const char* value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(value);
}
inline void MatchParticipant::set_race(const char* value, size_t size) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  race_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchParticipant::mutable_race() {
  set_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    race_ = new ::std::string;
  }
  return race_;
}
inline ::std::string* MatchParticipant::release_race() {
  clear_has_race();
  if (race_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = race_;
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchParticipant::set_allocated_race(::std::string* race) {
  if (race_ != &::google::protobuf::internal::kEmptyString) {
    delete race_;
  }
  if (race) {
    set_has_race();
    race_ = race;
  } else {
    clear_has_race();
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MatchResult

// required .protobufs.Region region = 1;
inline bool MatchResult::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchResult::set_has_region() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchResult::clear_has_region() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchResult::clear_region() {
  region_ = 1;
  clear_has_region();
}
inline ::protobufs::Region MatchResult::region() const {
  return static_cast< ::protobufs::Region >(region_);
}
inline void MatchResult::set_region(::protobufs::Region value) {
  assert(::protobufs::Region_IsValid(value));
  set_has_region();
  region_ = value;
}

// required .protobufs.Map map = 2;
inline bool MatchResult::has_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchResult::set_has_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchResult::clear_has_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchResult::clear_map() {
  if (map_ != NULL) map_->::protobufs::Map::Clear();
  clear_has_map();
}
inline const ::protobufs::Map& MatchResult::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::protobufs::Map* MatchResult::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::protobufs::Map;
  return map_;
}
inline ::protobufs::Map* MatchResult::release_map() {
  clear_has_map();
  ::protobufs::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void MatchResult::set_allocated_map(::protobufs::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// repeated .protobufs.MatchParticipant participant = 3;
inline int MatchResult::participant_size() const {
  return participant_.size();
}
inline void MatchResult::clear_participant() {
  participant_.Clear();
}
inline const ::protobufs::MatchParticipant& MatchResult::participant(int index) const {
  return participant_.Get(index);
}
inline ::protobufs::MatchParticipant* MatchResult::mutable_participant(int index) {
  return participant_.Mutable(index);
}
inline ::protobufs::MatchParticipant* MatchResult::add_participant() {
  return participant_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobufs::MatchParticipant >&
MatchResult::participant() const {
  return participant_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobufs::MatchParticipant >*
MatchResult::mutable_participant() {
  return &participant_;
}

// -------------------------------------------------------------------

// BroadcastAlert

// required string message = 2;
inline bool BroadcastAlert::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastAlert::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastAlert::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastAlert::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& BroadcastAlert::message() const {
  return *message_;
}
inline void BroadcastAlert::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void BroadcastAlert::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void BroadcastAlert::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastAlert::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* BroadcastAlert::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BroadcastAlert::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 predefined = 1;
inline bool BroadcastAlert::has_predefined() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastAlert::set_has_predefined() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastAlert::clear_has_predefined() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastAlert::clear_predefined() {
  predefined_ = 0;
  clear_has_predefined();
}
inline ::google::protobuf::int32 BroadcastAlert::predefined() const {
  return predefined_;
}
inline void BroadcastAlert::set_predefined(::google::protobuf::int32 value) {
  set_has_predefined();
  predefined_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobufs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobufs::HandshakeResponse_HandshakeStatus>() {
  return ::protobufs::HandshakeResponse_HandshakeStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protobufs::Region>() {
  return ::protobufs::Region_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_eros_2eproto__INCLUDED
